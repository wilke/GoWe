package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

// embeddedCWL is a minimal single-step workflow that runs "echo smoke-test-ok"
// via the local executor. The scheduler resolves _base_command from the
// CommandLineTool's baseCommand field.
const embeddedCWL = `cwlVersion: v1.2
$graph:
  - id: echo-tool
    class: CommandLineTool
    baseCommand: ["echo", "smoke-test-ok"]
    inputs:
      tag: { type: string }
    outputs:
      out: { type: File, outputBinding: { glob: "*.txt" } }

  - id: main
    class: Workflow
    inputs:
      tag: string
    steps:
      echo:
        run: "#echo-tool"
        in:
          tag: tag
        out: [out]
    outputs:
      result:
        type: File
        outputSource: echo/out
`

type check struct {
	Name   string
	Passed bool
	Detail string
}

// envelope mirrors model.Response for decoding.
type envelope struct {
	Status    string          `json:"status"`
	RequestID string          `json:"request_id"`
	Data      json.RawMessage `json:"data"`
	Error     *struct {
		Code    string `json:"code"`
		Message string `json:"message"`
	} `json:"error"`
}

func main() {
	addr := flag.String("addr", "http://localhost:8080", "GoWe server address")
	timeout := flag.Duration("timeout", 2*time.Minute, "Max time to wait for submission to complete")
	noCleanup := flag.Bool("no-cleanup", false, "Skip cleanup (leave workflow/submission for inspection)")
	flag.Parse()

	base := strings.TrimRight(*addr, "/")
	client := &http.Client{Timeout: 30 * time.Second}

	var results []check
	var workflowID, submissionID string

	// 1. Health check.
	results = append(results, checkHealth(client, base))
	if !results[len(results)-1].Passed {
		fmt.Fprintf(os.Stderr, "Server unreachable at %s — aborting.\n", base)
		printReport(results)
		os.Exit(1)
	}

	// 2. Create workflow.
	wfCheck, wfID := checkCreateWorkflow(client, base)
	results = append(results, wfCheck)
	workflowID = wfID
	if workflowID == "" {
		printReport(results)
		os.Exit(1)
	}

	// 3. Get workflow.
	results = append(results, checkGetWorkflow(client, base, workflowID))

	// 4. Validate workflow.
	results = append(results, checkValidateWorkflow(client, base, workflowID))

	// 5. Submit workflow.
	subCheck, subID := checkCreateSubmission(client, base, workflowID)
	results = append(results, subCheck)
	submissionID = subID
	if submissionID == "" {
		if !*noCleanup && workflowID != "" {
			deleteWorkflow(client, base, workflowID)
		}
		printReport(results)
		os.Exit(1)
	}

	// 6. Poll submission until terminal.
	pollCheck, finalState := checkPollSubmission(client, base, submissionID, *timeout)
	results = append(results, pollCheck)

	// 7. Verify tasks.
	taskChecks, taskIDs := checkTasks(client, base, submissionID, finalState)
	results = append(results, taskChecks...)

	// 8. Verify task logs.
	for _, tid := range taskIDs {
		results = append(results, checkTaskLogs(client, base, submissionID, tid))
	}

	// 9. Cleanup.
	if !*noCleanup && workflowID != "" {
		results = append(results, checkDeleteWorkflow(client, base, workflowID))
	}

	printReport(results)

	for _, r := range results {
		if !r.Passed {
			os.Exit(1)
		}
	}
}

// --- Check functions ---

func checkHealth(client *http.Client, base string) check {
	env, err := doGet(client, base+"/api/v1/health")
	if err != nil {
		return check{Name: "health", Detail: fmt.Sprintf("unreachable: %v", err)}
	}

	var health struct {
		Status    string            `json:"status"`
		Version   string            `json:"version"`
		Uptime    string            `json:"uptime"`
		Executors map[string]string `json:"executors"`
	}
	if err := json.Unmarshal(env.Data, &health); err != nil {
		return check{Name: "health", Detail: fmt.Sprintf("parse error: %v", err)}
	}

	executors := []string{}
	for name, status := range health.Executors {
		executors = append(executors, fmt.Sprintf("%s=%s", name, status))
	}

	return check{
		Name:   "health",
		Passed: health.Status == "healthy",
		Detail: fmt.Sprintf("%s, version=%s, uptime=%s, executors: %s",
			health.Status, health.Version, health.Uptime, strings.Join(executors, ", ")),
	}
}

func checkCreateWorkflow(client *http.Client, base string) (check, string) {
	body := map[string]string{
		"name":        "smoke-test-workflow",
		"description": "Auto-generated by smoke-test tool",
		"cwl":         embeddedCWL,
	}

	env, err := doPost(client, base+"/api/v1/workflows/", body, http.StatusCreated)
	if err != nil {
		return check{Name: "create workflow", Detail: fmt.Sprintf("error: %v", err)}, ""
	}

	var wf struct {
		ID        string `json:"id"`
		Name      string `json:"name"`
		StepCount int    `json:"step_count"`
		Steps     []struct {
			ID string `json:"id"`
		} `json:"steps"`
	}
	if err := json.Unmarshal(env.Data, &wf); err != nil {
		return check{Name: "create workflow", Detail: fmt.Sprintf("parse error: %v", err)}, ""
	}

	stepCount := len(wf.Steps)
	if stepCount == 0 {
		stepCount = wf.StepCount
	}

	return check{
		Name:   "create workflow",
		Passed: wf.ID != "" && strings.HasPrefix(wf.ID, "wf_"),
		Detail: fmt.Sprintf("id=%s, name=%s, steps=%d", wf.ID, wf.Name, stepCount),
	}, wf.ID
}

func checkGetWorkflow(client *http.Client, base, wfID string) check {
	env, err := doGet(client, base+"/api/v1/workflows/"+wfID+"/")
	if err != nil {
		return check{Name: "get workflow", Detail: fmt.Sprintf("error: %v", err)}
	}

	var wf struct {
		ID    string `json:"id"`
		Name  string `json:"name"`
		Steps []struct {
			ID        string   `json:"id"`
			DependsOn []string `json:"depends_on"`
		} `json:"steps"`
	}
	if err := json.Unmarshal(env.Data, &wf); err != nil {
		return check{Name: "get workflow", Detail: fmt.Sprintf("parse error: %v", err)}
	}

	stepIDs := []string{}
	for _, s := range wf.Steps {
		stepIDs = append(stepIDs, s.ID)
	}

	return check{
		Name:   "get workflow",
		Passed: wf.ID == wfID && len(wf.Steps) > 0,
		Detail: fmt.Sprintf("name=%s, steps=[%s]", wf.Name, strings.Join(stepIDs, ", ")),
	}
}

func checkValidateWorkflow(client *http.Client, base, wfID string) check {
	env, err := doPost(client, base+"/api/v1/workflows/"+wfID+"/validate", nil, http.StatusOK)
	if err != nil {
		return check{Name: "validate workflow", Detail: fmt.Sprintf("error: %v", err)}
	}

	var result struct {
		Valid bool `json:"valid"`
	}
	if err := json.Unmarshal(env.Data, &result); err != nil {
		return check{Name: "validate workflow", Detail: fmt.Sprintf("parse error: %v", err)}
	}

	return check{
		Name:   "validate workflow",
		Passed: result.Valid,
		Detail: fmt.Sprintf("valid=%v", result.Valid),
	}
}

func checkCreateSubmission(client *http.Client, base, wfID string) (check, string) {
	body := map[string]any{
		"workflow_id": wfID,
		"inputs":      map[string]any{"tag": "smoke-test"},
		"labels":      map[string]string{"source": "smoke-test"},
	}

	env, err := doPost(client, base+"/api/v1/submissions/", body, http.StatusCreated)
	if err != nil {
		return check{Name: "create submission", Detail: fmt.Sprintf("error: %v", err)}, ""
	}

	var sub struct {
		ID    string `json:"id"`
		State string `json:"state"`
		Tasks []struct {
			ID     string `json:"id"`
			StepID string `json:"step_id"`
			State  string `json:"state"`
		} `json:"tasks"`
	}
	if err := json.Unmarshal(env.Data, &sub); err != nil {
		return check{Name: "create submission", Detail: fmt.Sprintf("parse error: %v", err)}, ""
	}

	taskSummary := []string{}
	for _, t := range sub.Tasks {
		taskSummary = append(taskSummary, fmt.Sprintf("%s(%s)", t.StepID, t.State))
	}

	return check{
		Name:   "create submission",
		Passed: sub.ID != "" && strings.HasPrefix(sub.ID, "sub_"),
		Detail: fmt.Sprintf("id=%s, state=%s, tasks=[%s]", sub.ID, sub.State, strings.Join(taskSummary, ", ")),
	}, sub.ID
}

func checkPollSubmission(client *http.Client, base, subID string, timeout time.Duration) (check, string) {
	deadline := time.Now().Add(timeout)
	poll := 2 * time.Second

	var lastState string
	for time.Now().Before(deadline) {
		env, err := doGet(client, base+"/api/v1/submissions/"+subID+"/")
		if err != nil {
			return check{Name: "poll submission", Detail: fmt.Sprintf("error: %v", err)}, ""
		}

		var sub struct {
			State string `json:"state"`
		}
		if err := json.Unmarshal(env.Data, &sub); err != nil {
			return check{Name: "poll submission", Detail: fmt.Sprintf("parse error: %v", err)}, ""
		}

		lastState = sub.State

		switch sub.State {
		case "COMPLETED":
			return check{
				Name:   "poll submission",
				Passed: true,
				Detail: "COMPLETED",
			}, sub.State
		case "FAILED", "CANCELLED":
			return check{
				Name:   "poll submission",
				Detail: fmt.Sprintf("terminal state: %s", sub.State),
			}, sub.State
		}

		time.Sleep(poll)
	}

	return check{
		Name:   "poll submission",
		Detail: fmt.Sprintf("timeout after %s, last state: %s", timeout, lastState),
	}, lastState
}

func checkTasks(client *http.Client, base, subID, finalState string) ([]check, []string) {
	env, err := doGet(client, base+"/api/v1/submissions/"+subID+"/tasks/")
	if err != nil {
		return []check{{Name: "list tasks", Detail: fmt.Sprintf("error: %v", err)}}, nil
	}

	var tasks []struct {
		ID           string `json:"id"`
		StepID       string `json:"step_id"`
		State        string `json:"state"`
		ExecutorType string `json:"executor_type"`
	}
	if err := json.Unmarshal(env.Data, &tasks); err != nil {
		return []check{{Name: "list tasks", Detail: fmt.Sprintf("parse error: %v", err)}}, nil
	}

	var results []check
	var taskIDs []string

	for _, t := range tasks {
		taskIDs = append(taskIDs, t.ID)

		expectedState := "SUCCESS"
		if finalState == "FAILED" || finalState == "CANCELLED" {
			expectedState = "" // don't assert on individual tasks if submission failed
		}

		passed := expectedState == "" || t.State == expectedState
		results = append(results, check{
			Name:   fmt.Sprintf("task %s (%s)", t.StepID, t.ExecutorType),
			Passed: passed,
			Detail: fmt.Sprintf("id=%s, state=%s", t.ID, t.State),
		})
	}

	if len(tasks) == 0 {
		results = append(results, check{Name: "list tasks", Detail: "no tasks found"})
	}

	return results, taskIDs
}

func checkTaskLogs(client *http.Client, base, subID, taskID string) check {
	env, err := doGet(client, base+"/api/v1/submissions/"+subID+"/tasks/"+taskID+"/logs")
	if err != nil {
		return check{Name: "task logs " + taskID[:16], Detail: fmt.Sprintf("error: %v", err)}
	}

	var logs struct {
		Stdout   string `json:"stdout"`
		Stderr   string `json:"stderr"`
		ExitCode *int   `json:"exit_code"`
	}
	if err := json.Unmarshal(env.Data, &logs); err != nil {
		return check{Name: "task logs " + taskID[:16], Detail: fmt.Sprintf("parse error: %v", err)}
	}

	hasOutput := logs.Stdout != "" || logs.Stderr != ""
	exitOK := logs.ExitCode != nil && *logs.ExitCode == 0
	stdoutPreview := truncate(strings.TrimSpace(logs.Stdout), 80)

	exitStr := "<nil>"
	if logs.ExitCode != nil {
		exitStr = fmt.Sprintf("%d", *logs.ExitCode)
	}
	detail := fmt.Sprintf("exit_code=%s, stdout=%q", exitStr, stdoutPreview)
	if logs.Stderr != "" {
		detail += fmt.Sprintf(", stderr=%q", truncate(strings.TrimSpace(logs.Stderr), 80))
	}

	return check{
		Name:   "task logs",
		Passed: hasOutput && exitOK,
		Detail: detail,
	}
}

func checkDeleteWorkflow(client *http.Client, base, wfID string) check {
	req, err := http.NewRequest(http.MethodDelete, base+"/api/v1/workflows/"+wfID+"/", nil)
	if err != nil {
		return check{Name: "cleanup workflow", Detail: fmt.Sprintf("create request: %v", err)}
	}
	resp, err := client.Do(req)
	if err != nil {
		return check{Name: "cleanup workflow", Detail: fmt.Sprintf("error: %v", err)}
	}
	defer resp.Body.Close()
	io.ReadAll(resp.Body)

	return check{
		Name:   "cleanup workflow",
		Passed: resp.StatusCode == http.StatusOK,
		Detail: fmt.Sprintf("HTTP %d", resp.StatusCode),
	}
}

func deleteWorkflow(client *http.Client, base, wfID string) {
	req, _ := http.NewRequest(http.MethodDelete, base+"/api/v1/workflows/"+wfID+"/", nil)
	if req != nil {
		resp, err := client.Do(req)
		if err == nil {
			resp.Body.Close()
		}
	}
}

// --- HTTP helpers ---

func doGet(client *http.Client, url string) (*envelope, error) {
	resp, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read response: %w", err)
	}

	var env envelope
	if err := json.Unmarshal(body, &env); err != nil {
		return nil, fmt.Errorf("parse response: %w (body: %s)", err, truncate(string(body), 200))
	}

	if env.Error != nil {
		return &env, fmt.Errorf("API error %s: %s", env.Error.Code, env.Error.Message)
	}

	return &env, nil
}

func doPost(client *http.Client, url string, payload any, expectStatus int) (*envelope, error) {
	var bodyReader io.Reader
	if payload != nil {
		data, err := json.Marshal(payload)
		if err != nil {
			return nil, fmt.Errorf("marshal request: %w", err)
		}
		bodyReader = bytes.NewReader(data)
	} else {
		bodyReader = strings.NewReader("{}")
	}

	resp, err := client.Post(url, "application/json", bodyReader)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read response: %w", err)
	}

	var env envelope
	if err := json.Unmarshal(body, &env); err != nil {
		return nil, fmt.Errorf("parse response (HTTP %d): %w (body: %s)", resp.StatusCode, err, truncate(string(body), 200))
	}

	if resp.StatusCode != expectStatus {
		msg := fmt.Sprintf("expected HTTP %d, got %d", expectStatus, resp.StatusCode)
		if env.Error != nil {
			msg += fmt.Sprintf(": %s", env.Error.Message)
		}
		return &env, fmt.Errorf("%s", msg)
	}

	return &env, nil
}

// --- Report ---

func printReport(results []check) {
	fmt.Println()
	fmt.Println("GoWe API Smoke Test Report")
	fmt.Println("==========================")

	passed, failed := 0, 0
	for _, r := range results {
		tag := "FAIL"
		if r.Passed {
			tag = "PASS"
			passed++
		} else {
			failed++
		}
		fmt.Printf("[%s] %s — %s\n", tag, r.Name, r.Detail)
	}

	fmt.Println()
	fmt.Printf("Summary: %d/%d passed", passed, len(results))
	if failed > 0 {
		fmt.Printf(", %d failed", failed)
	}
	fmt.Println()
}

func truncate(s string, n int) string {
	if len(s) <= n {
		return s
	}
	return s[:n] + "..."
}
